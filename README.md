# EndorphinJS
EndorphinJS — это библиотека для построения пользовательских интерфейсов с помощью DOM-компонентов. В основе библиотеки лежит декларативный шаблонизатор Endorphin, цель которого обеспечить инкрементальное обновление UI в браузере, а также рендеринг на стороне сервера _на любом языке программирования_.

## Основные возможности

* Декларативный шаблонизатор, имеющий JavaScript-подобный синтаксис выражений для удобного обращения к данным. Синтаксис выражений, с одной стороны, намеренно ограничен по сравнению с JavaScript, но также имеет расширенную семантику для работы с данными.
* В отличие от React/Vue.js/Svelte, каждый компонент Endorphin-компонент имеет реальное представление в виде DOM-элемента. Поэтому Endorphin-компоненты больше похожи на веб-компоненты, но ими не являются (об этом ниже). Такой подход _радикально_ упрощает отладку и стилизацию компонентов: все они доступны прямо в инструментах разработчика _любого_ браузера, в том числе через протокол удалённой отладки.
* Отсутствие стороннего runtime для работы приложения на EndorphinJS: код, необходимый для работы приложения, определяется на этапе компиляции и внедряется непосредственно в приложение. Сам runtime достаточно компактный: вес *всего* кода — около 4 КБ (gzip).
* Изоляция CSS: на этапе сборки весь CSS компонента полностью изолируется и применяется только к своему компоненту.
* Очень быстрое обновление UI: никаких Virtual DOM, шаблон компонента анализируется на этапе сборки и для него генерируется код, который *обновляет только изменяемые части шаблона*. Сгенерированный код оптимизирован под особенности JIT-компиляторов современных JS-движков для большей производительности.
* Endorphin-компоненты не скрывают, а наоборот, пропагандируют использование Web API: вы можете обращаться к содержимому компонента как к любому содержимому DOM-элемента, а также манипулировать содержимым. Сам Endorphin работает только с теми данными, которые сам создал. Это значит, что вы можете манипулировать DOM-элементами компонента (в разумных пределах, конечно) и не боятся, что следующий цикл перерисовки компонента всё отменит.
* Встроенная поддержка анимаций появления и удаления элемента на основе CSS Animations.
* Endorphin-приложение можно безопасно вставлять на любой сайт: за счёт полной изоляции и отсутствия стороннего runtime можно быть уверенным, что приложение никак не повлияет на остальные части сайта.

## Первое знакомство

Давайте создадим наш первый компонент на Endorphin:

```html
<!-- my-component.html -->
<style>
button {
    appearance: none;
    display: inline-block;
    background: none;
    border: 3px solid blue;
    padding: 5px;
}
</style>
<template>
    <button on:click={ #count++ }>Click me</button>
    <e:if test={#count}>
        <p>Clicked { #count } { #count !== 1 ? 'times' : 'time' }</p>
    </e:if>
</template>
<script>
export function state() {
    return { count: 0 }
}

export function didMount(component) {
    console.log('Mounted component', component.nodeName);
}
</script>
```

И создадим приложение, которое вставляет этот компонент на страницу:

```js
// app.js
import endorphin from 'endorphin';
import * as MyComponent from './my-component.html';

endorphin('my-component', MyComponent, {
    target: document.body
});
```

После [сборки](https://github.com/endorphinjs/samples) мы получим приложение с кнопкой Click me, клик на которую будет менять надпись с количеством кликов. Если посмотреть через DevTools, то вы увидите на странице элемент `<my-component>` и его содержимое. Из приведённого примера вы должны узнать следующее:

* Компонент описывается стандартными HTML-тэгами: слили описываются в тэге `<style>` или подключаются через `<link rel="stylesheet" />`, шаблон описывается в тэге `<template>`, а поведение — в тэге `<script>` либо подключается из стороннего файла через `<script src="...">`.
* Имя файла используется как имя DOM-компонента. Так как Endorphin-компоненты идейно похожи на веб-компоненты, имя файла должно содержать дефис, однако это поведение можно переопределить (см. раздел Вложенные компоненты).
* В стилях можно безопасно использовать в том числе и тэги для стилизации: за счёт изоляции можно быть уверенным, что стили для `button` из `my-component.html` никак не повлияют на кнопку из `other-component.html`. Стандартный CSS содержит несколько расширений, позволяющих управлять изоляцией (см. раздел CSS).
* Шаблон (как и всё описание компонента) использует XML-подобный синтаксис. Это означает, что все тэги должны быть закрыты (`<p></p>`) либо иметь закрывающий слэш в конце (`<br />`). При этом, в отличие от XML, можно не экранировать спецсимволы вроде `<` и `>`, а также не обязательно использовать кавычки для значений атрибутов.
* Контрольные инструкции для описания динамических частей шаблона также описываются XML-тэгами, как правило, с префиксом `e:`. Динамические выражения указываются внутри фигурных скобок: `{ #count }`. Динамические значения атрибутов пишутся как `name={...}`, однако если ваш редактор/IDE не понимает такой синтаксис, можно писать `name="{...}"`.
* Поведение компонента описывается в виде ES-модуля: вы экспортируете объекты и функции, которые известны Endorphin runtime. В экспортируемые функции первым аргументом *всегда* (кроме некоторых случаев с обработчиками событий) передаётся экземпляр компонента (DOM-элемент), которым можно управлять. Таким образом, Endorphin продвигает функциональный подход к описанию поведения компонента и избавляет от множества проблем с `this`.
* У компонента есть несколько источников данных: *props* (внешний контракт, передаётся в компонент снаружи), *state* (внутренний контракт, управляется самим компонентом) и *store* (данные приложения). Для удобства внутри шаблона используется используется специальный префикс для каждого источника данных:
    * Для обращения к значению из *props* достаточно написать `propName`, то есть обращаться как к глобальной переменной.
    * Для обращения к *state* используется префикс `#` (по аналогии с приватными свойствами классов в JS): `#stateName`.
    * Для обращения к *store* используется префикс `$`: `$storeName`.

## Шаблон

Как было отмечено выше, шаблон представляет из себя XML-подобный со специальными тэгами, которые управляют содержимым компонента.

## `<e:variable>`

Создаёт локальные переменные шаблона. Именем переменной является название атрибута в `<e:variable>`. Для обращения к локальной переменной используется префикс `@`:

```html
<e:variable sum={a + b} enabled={isEnabled != null} />

<e:if test={@enabled}>
    Sum is { @sum }
</e:if>
```

## `<e:if>`

Выводит содержимое, если условие истинно.

* `test` — выражение для проверки.

```html
<e:if test={a > 1}>
    <p><code>a</code> is greater than 1</p>
</e:if>
```

Для удобства, если выводить нужно только один элемент, условие можно записать как директиву `e:if` у элемента:

```html
<p e:if={a > 1}><code>a</code> is greater than 1</p>
```

## `<e:choose>`/`<e:when>`/`<e:otherwise>`

Аналог `if`/`else if`/`else`: внутри элемента `<e:choose>` перечисляются секции `<e:when test={...}>`, из которых выполнится первая, в которой условие атрибута `test` истинной. Если ни одно из условий не было истинным, сработает секция `<e:otherwise>`:

```html
<e:choose>
    <e:when test={#color === 'red'}>Color is red</e:when>
    <e:when test={#color === 'blue' || #color === 'green'}>Color is blue or green</e:when>
    <e:otherwise>Unknown color</e:otherwise>
</e:choose>
```

## `<e:for-each>`

Выводит содержимое для каждого элемента из полученной коллекции.

* `select` — выражение, которое должно вернуть коллекцию для интерации. Коллекция определяется по наличию метода `.forEach` у результата, то есть это может быть массив, `Map`, `Set` или любой другой объект, поддерживающий семантику `.forEach` коллекций. Если результат выражения не содержит этот метод, цикл выполнится один раз для этого значения.
* [`key`] — выражение, которое должно строковый ключ для текущего элемента. При наличии этого ключа сгенерированный результат «привязывается» к элементу с этим ключом. В этом случае при пересортировке данных в коллекции гарантируется, что именно эти DOM-элементы, сгенерированные на прошлом шаге отрисовки, будут использоваться для отрисовки этого же элемента. В основном это используется вместе с анимациями, когда нужно гарантировать идентичность элементов при перерисовке, а также в некоторых случаях может повысить производительность.

Для каждого элемента коллекции создаётся три локальные переменные:

* `@value` — значение элемента коллекции
* `@key` — ключ элемента в коллекции
* `@index` — порядковый номер элемента в коллекции, начиная с 0 (для массива это значение равно `@key`).

```html
<ul>
    <e:for-each select={items}>
        <li value={@key}>Value is { @value }<li>
    </e:for-each>
</ul>
```

Использование `key`:

```html
<ul>
    <e:for-each select={items} key={@value.id}>
        <li value={@key}>{ @value.id }: { @value.name }<li>
    </e:for-each>
</ul>
```


